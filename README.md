## Spring Boot, Spring Cloud Oauth2, Spring Cloud Netflix Eureka, Spring CLoud Zuul, Hystrix Monitoring Dashboard, Swagger 2, Spring Data JPA, MySQL



# Overview

The architecture is composed by five services:

   * `micro-eureka-server`: Service **Discovery Server** created with Eureka
   * `micro-api-getway`: API Gateway created with Zuul that uses the discovery-service to send the requests to the services. It uses Ribbon as Load Balancer
   * `micro-auth-service`: Simple REST service created with `Spring Boot, Spring Cloud Oauth2, Spring Data JPA, MySQL` to use as an **authorization service**
   * `micro-product-service`: Simple REST service created with `Spring Boot, Spring Cloud Oauth2, Spring Data JPA, MySQL` to use as an **resource service**
   * `micro-sales-service`: Simple REST service created with `Spring Boot, Spring Cloud Oauth2, Spring Data JPA, MySQL` to use as an **resource service**
 
##
# micro-eureka-service

Eureka Server is an application that holds the information about all client-service applications. Every Micro service will register into the Eureka server and Eureka server knows all the client applications running on each port and IP address. Eureka Server is also known as Discovery Server.

## How to run?

### Build Project
Now, you can create an executable JAR file, and run the Spring Boot application by using the Maven or Gradle commands shown below −
For Maven, use the command as shown below −

`mvn clean install`
or

**Project import in sts4 IDE** 
```File >import >maven >Existing maven project > Root Directory-Browse > Select project form root folder > Finish```

### Run project 

After “BUILD SUCCESSFUL”, you can find the JAR file under the build/libs directory.
Now, run the JAR file by using the following command −

 `java –jar <JARFILE> `

 Run on sts IDE
 
 `click right button on the project >Run As >Spring Boot App`
 
 Discovery-Service URL: `http://localhost:8761`



# micro-auth-service
Whenever we think of microservices and distributed applications, the first point that comes to mind is security. Obviously, in distributed architectures, it is really difficult to manage security as we do not have much control over the application. So in this situation, we always need to have a central entry point to this distributed architecture. This is the reason why, in microservices, we have a separate and dedicated layer for all these purposes. This layer is known as the API Gateway. It is an entry point for a microservice's architecture.

To maintain security, the first necessary condition is to restrict direct microservice calls for outside callers. All calls should only go through the API Gateway. The API Gateway is mainly responsible for authentication and authorization of the API requests made by external callers. Also, this layer performs the routing of API requests that come from external clients to respective microservices. This allows the API Gateway to act as an entry point for all its respective microservices. So, we can say the API Gateway is mainly responsible for the security of microservices.

## Oauth2
In this Spring security oauth2 tutorial, learn to build an authorization server to authenticate your identity to provide access_token, which you can use to request data from resource server.

***Introduction to OAuth 2***
OAuth 2 is an authorization method to provide access to protected resources over the HTTP protocol. Primarily, oauth2 enables a third-party application to obtain limited access to an HTTP service –

* either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and the HTTP service
* or by allowing the third-party application to obtain access on its own behalf.

**OAuth2 Roles:** There are four roles that can be applied on OAuth2:

* `Resource Owner`: The owner of the resource — this is pretty self-explanatory.
* `Resource Server`: This serves resources that are protected by the OAuth2 token.
* `Client`: The application accessing the resource server.
* `Authorization Server`:  This is the server issuing access tokens to the client after successfully authenticating the resource owner and obtaining authorization.


**OAuth2 Tokens:** Tokens are implementation specific random strings, generated by the authorization server.

* `Access Token`: Sent with each request, usually valid for about an hour only.
* `Refresh Token`: It is used to get a 00new access token, not sent with each request, usually lives longer than access token.



### Test Product service Service

Now that both the services are up and running, let’s test the `getAllProducts` form product service method by passing the earlier access token obtained for user `admin` in the header as shown below. Here `48b3ea3c-36c5-4359-accb-35086a3e8ede` is the `access_token` for `admin`.

Here `admin` belongs to `PRODUCT_VIEW` and hence he can view the products.

### HTTP GET Request
```
curl --request GET http://localhost:8180/product-api/product/find \
     --header "Authorization:Bearer 48b3ea3c-36c5-4359-accb-35086a3e8ede"
```
# Zuul API Gateway

***Enable Zuul Service Proxy***
Now add the `@EnableZuulProxy` and `@EnableEurekaClient` annotation on Spring boot application class present in src folder. With this annotation, this artifact will act like a Zuul service proxy and will enable all the features of a API gateway layer as described before. We will then add some filters and route configurations.
```
@SpringBootApplication
@EnableZuulProxy
@EnableEurekaClient
public class ZuulApiGetWayRunner {

	public static void main(String[] args) {
		SpringApplication.run(ZuulApiGetWayRunner.class, args);
		System.out.println("Zuul server is running...");
	}

	@Bean
	public PreFilter preFilter() {
		return new PreFilter();
	}

	@Bean
	public PostFilter postFilter() {
		return new PostFilter();
	}

	@Bean
	public ErrorFilter errorFilter() {
		return new ErrorFilter();
	}

	@Bean
	public RouteFilter routeFilter() {
		return new RouteFilter();
	}
}
```
***Zuul routes configuration***
Open application.properties and add below entries-
```
#Will start the gateway server @8080
server.port=8180
spring.application.name=zuul-server

#eureka.client.serviceUrl.defaultZone=http://eureka:8761/eureka/
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/
eureka.instance.preferIpAddress=true

# A prefix that can added to beginning of all requests. 
#zuul.prefix=/api

# Disable accessing services using service name (i.e. user-service).
# They should be only accessed through the path defined below.
zuul.ignored-services=*



zuul.routes.third.id=auth-server
zuul.routes.secound.id=sales-server
zuul.routes.first.id=product-server

#Disable Spring Boot basic authentication
security.basic.enabled=false
security.user.password=none


# Map paths to employee service
zuul.routes.product-server.path=/product-api/**
zuul.routes.product-server.serviceId=product-server
zuul.routes.product-server.stripPrefix=false

# Map paths to sales service
zuul.routes.sales-server.path=/sales-api/**
zuul.routes.sales-server.serviceId=sales-server
zuul.routes.sales-server.stripPrefix=false

# Map paths to user service
zuul.routes.auth-server.path=/auth-api/**
zuul.routes.auth-server.serviceId=auth-server
zuul.routes.auth-server.stripPrefix=false

#zuul.routes.first.url=employee-service
#zuul.routes.second.url=user-server


eureka.instance.lease-expiration-duration-in-seconds=1
eureka.instance.lease-renewal-interval-in-seconds=2
#eureka.client.healthcheck.enabled=true
#logging.level.zuul.api.getway=DEBUG


#Set the Hystrix isolation policy to the thread pool
zuul.ribbon-isolation-strategy=thread



#each route uses a separate thread pool
zuul.thread-pool.use-separate-thread-pools=true
```
